# Copyright 2024 New Vector Ltd
#
# SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-Element-Commercial

import json
import random
import string
from collections.abc import Iterator
from pathlib import Path
from typing import Any

import pyhelm3
import pytest
import yaml

from . import component_details, shared_components_details, values_files_to_components


@pytest.fixture(scope="session")
async def release_name():
    return f"pytest-{''.join(random.choices(string.ascii_lowercase, k=6))}"


@pytest.fixture(scope="session")
async def helm_client():
    return pyhelm3.Client()


@pytest.fixture(scope="session")
async def chart(helm_client: pyhelm3.Client):
    return await helm_client.get_chart("charts/matrix-stack")


@pytest.fixture(scope="function")
def component(values_file):
    return values_files_to_components[values_file]


@pytest.fixture(scope="session")
def base_values(values_file) -> dict[str, Any]:
    return yaml.safe_load(Path("charts/matrix-stack/values.yaml").read_text("utf-8"))


@pytest.fixture(scope="function")
def values(values_file) -> dict[str, Any]:
    v = yaml.safe_load((Path("charts/matrix-stack/ci") / values_file).read_text("utf-8"))
    if not v.get("initSecrets"):
        v["initSecrets"] = {"enabled": True}
    if not v.get("postgres"):
        v["postgres"] = {"enabled": True}
    if not v.get("wellKnownDelegation"):
        v["wellKnownDelegation"] = {"enabled": True}
    return v


@pytest.fixture(scope="function")
async def templates(chart: pyhelm3.Chart, release_name: str, values: dict[str, Any]):
    return list([template for template in await helm_template(chart, release_name, values) if template is not None])


@pytest.fixture(scope="function")
def other_secrets(release_name, values, templates):
    return list(generated_secrets(release_name, values, templates)) + list(external_secrets(release_name, values))


def generated_secrets(release_name: str, values: Any | None, helm_generated_templates: list[Any]) -> Iterator[Any]:
    if values["initSecrets"]["enabled"]:
        init_secrets_job = None
        for template in helm_generated_templates:
            if template["kind"] == "Job" and template["metadata"]["name"] == f"{release_name}-init-secrets":
                init_secrets_job = template
                break
        else:
            # We don't have an init-secrets job
            return

        command_line = (
            init_secrets_job.get("spec", {})
            .get("template", {})
            .get("spec", {})
            .get("containers", [{}])[0]
            .get("command", {})
        )
        assert len(command_line) == 6, "Unexpected command line in the init-secrets job"
        assert command_line[2] == "-secrets", "Can't find the secrets args for the init-secrets job"
        assert command_line[4] == "-labels", "Can't find the labels args for the init-secrets job"

        requested_secrets = command_line[3].split(",")
        requested_labels = {label.split("=")[0]: label.split("=")[1] for label in command_line[5].split(",")}
        generated_secrets_to_keys = {}
        for requested_secret in requested_secrets:
            secret_parts = requested_secret.split(":")
            generated_secrets_to_keys.setdefault(secret_parts[0], []).append(secret_parts[1])

        for secret_name, secret_keys in generated_secrets_to_keys.items():
            yield {
                "kind": "Secret",
                "metadata": {"name": secret_name, "labels": requested_labels},
                "data": {
                    secret_key: "".join(random.choices(string.ascii_lowercase, k=10)) for secret_key in secret_keys
                },
            }


def external_secrets(release_name, values):
    def find_credential(values_fragment):
        if isinstance(values_fragment, (dict, list)):
            for value in values_fragment.values() if isinstance(values_fragment, dict) else values_fragment:
                if isinstance(value, dict):
                    if "secret" in value and "secretKey" in value and len(value) == 2:
                        yield (value["secret"].replace("{{ $.Release.Name }}", release_name), value["secretKey"])
                    # We don't care about credentials in the Helm values as those will
                    # be added to the Secret generated by the chart and won't be external
                    else:
                        yield from find_credential(value)
                elif isinstance(value, list):
                    yield from find_credential(value)

    external_secrets_to_keys = {}
    for secret_name, secretKey in find_credential(values):
        external_secrets_to_keys.setdefault(secret_name, []).append(secretKey)

    for secret_name, secret_keys in external_secrets_to_keys.items():
        yield {
            "kind": "Secret",
            "metadata": {
                "name": secret_name,
            },
            "data": {secret_key: "".join(random.choices(string.ascii_lowercase, k=10)) for secret_key in secret_keys},
        }


async def helm_template(chart: pyhelm3.Chart, release_name: str, values: Any | None) -> Iterator[Any]:
    """Generate template with ServiceMonitor API Versions enabled

    The native pyhelm3 template command does expose the --api-versions flag,
    so we implement it here.

    Args:
        chart (pyhelm3.Chart): The chart
        release_name (str): The release name
        values (Any, optional): The values to use

    Returns:
        Iterator[Any]: Iterating on manifests.
    """
    command = [
        "template",
        release_name,
        chart.ref,
        "-a",
        "monitoring.coreos.com/v1/ServiceMonitor",
        # We send the values in on stdin
        "--values",
        "-",
    ]
    return yaml.load_all(
        await pyhelm3.Command().run(command, json.dumps(values or {}).encode()), Loader=yaml.SafeLoader
    )


@pytest.fixture
def make_templates(chart: pyhelm3.Chart, release_name: str):
    async def _make_templates(values):
        return list([template for template in await helm_template(chart, release_name, values) if template is not None])

    return _make_templates


def iterate_component_parts(component, values, setter, if_condition, ignore_uses_parent_properties):
    if component_details[component][if_condition]:
        setter(values[component], values)
        for sub_component in component_details[component]["sub_components"]:
            if (
                ignore_uses_parent_properties
                or not component_details[component]["sub_components"][sub_component]["uses_parent_properties"]
            ):
                setter(values[component].setdefault(sub_component, {}), values)
    for shared_component in component_details[component].get("shared_components", []):
        if shared_components_details[shared_component][if_condition]:
            setter(values.setdefault(shared_component, {}), values)


def iterate_component_workload_parts(component, values, setter, ignore_uses_parent_properties=False):
    iterate_component_parts(component, values, setter, "has_workloads", ignore_uses_parent_properties)


def iterate_component_image_parts(component, values, setter):
    iterate_component_parts(component, values, setter, "has_image", False)


def get_or_empty(d, key):
    res = d.get(key, {})
    if res is not None:
        return res
    else:
        return {}
